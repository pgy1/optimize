# 中间件分析

###[Redis](https://redis.io/documentation)
>应用场景：会员信息储存、短信超时验证、历史数据缓存

>要点分析：

>1.发布/订阅消息系统
>2.内存优化
>3.大量插入数据
>4.分区
>5.事务

>管理要点分析：

>1.安全性
>2.高可用性
>3.数据持久化

###[Zookeeper](http://blog.csdn.net/tswisdom/article/details/41522069)

>分布式应用的痛点：局部故障（一个消息通过网络在两个节点之间传递时，网络如果发生故障，发送方并不知道接收方是否接收到了这个消息）。
>大部分分布式应用需要一个主控、协调控制器来管理物理分布的子进程。协调程序的反复编写浪费，且难以形成通用、伸缩性好的协调器。
>协调服务非常容易出错，并很难从故障中恢复。Zookeeper的设计目的就是为了减轻分布式应用程序所承担的协调任务，提供一些工具集，用来建立安全处理局部故障的分布式应用。
>ZooKeeper是一个分布式小文件系统，并且被设计为高可用性，通过选举算法和集群复制可以避免单点故障。
>由于是文件系统，即使所有的ZooKeeper节点全部挂掉，数据也不会丢失，重启服务器之后，数据即可恢复。
>另外ZooKeeper的节点更新是原子的，也就是说更新不是成功就是失败。
>主要解决的数据管理问题：如集群管理、统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等。

>（1）ZooKeeper的读写机制
>Zookeeper是一个由多个server组成的集群
>一个leader，多个follower
>每个server保存一份数据副本
>全局数据一致
>分布式读写
>更新请求转发，由leader实施
>（2）ZooKeeper的保证
>ZooKeeper运行非常快而且简单。虽然它的目标是构建更加复杂服务（例如同步）的基础，但它提供了一些保证，如下：
>1.顺序一致性：来自于客户端的更新，根据发送的先后被顺序实施。
>2.唯一的系统映像：尽管客户端连接到不同的服务器，但它们看到的一个唯一（一致性）的系统服务，client无论连接到哪个server，数据视图都是一致的。
>3.可靠性：一旦实施了一个更新，就会一直保持那种状态，直到客户端再次更新它，同时数据更新原子性，一次数据更新要么成功，要么失败。
>4.及时性：在一个确定的时间内，客户端看到的系统状态是最新的。
>（3）ZooKeeper特点
>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。
>可靠性：具有简单、健壮、良好的性能，如果消息m被一台服务器接受，那么它将被所有的服务器接受。
>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。 但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。
>等待无关(wait-free)：慢的或者失效的client，不得干预快速的client的请求，使得每个client都能有效的等待。
>原子性：更新只能成功或者失败，没有中间状态。
>顺序性：包括全局有序和偏序两种：
>全局有序：是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；
>偏序：是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面

###[ActiveMQ](http://activemq.apache.org/)

###[Kafka](http://kafka.apache.org/)

###[Hadoop](http://hadoop.apache.org/)

###[Spark](http://spark.apache.org/)
